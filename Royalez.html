<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lane Clash Prototype - Vs AI</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 10vh;
        }
        canvas {
            border: 4px solid #4b5563;
            background-color: #374151; /* Game arena background */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.5);
            cursor: crosshair; /* Indicate it's interactive */
        }
        .card-button {
            transition: all 0.1s ease-in-out;
            width: 100%; /* Ensure flex items fill grid space */
            position: relative;
        }
        .card-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        .card-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        /* Style for the card overlay when clicked */
        .card-active {
            border-bottom-color: #facc15 !important;
            box-shadow: 0 0 15px #facc15 !important;
        }
        /* Style for the cooldown overlay */
        .card-cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 0.75rem;
            pointer-events: none; /* Allows click events to pass through */
            transition: opacity 0.3s;
        }

        /* Styling for the Deck Selection Modal */
        .deck-card {
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.3s;
        }
        .deck-card.selected {
            outline: 4px solid #facc15;
            outline-offset: 2px;
            box-shadow: 0 0 20px #facc15;
        }
        .deck-card:hover {
            transform: scale(1.05);
        }

        /* --- Custom Styling for Ancient (Evolution Glow) --- */
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            70% { box-shadow: 0 0 0 8px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }
        
        .evo-glow {
            /* Initial shadow for visibility */
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.8); 
            border: 2px solid #10b981;
            /* Apply pulse animation */
            animation: pulse-green 2s infinite; 
        }
        .evo-glow.selected {
            /* Keep the green glow and add yellow selection outline */
            outline: 4px solid #facc15;
            box-shadow: 0 0 10px #10b981, 0 0 20px #facc15; 
            animation: none; /* Stop pulsing when selected */
        }
    </style>
</head>
<body class="p-4">

    <div id="game-container" class="flex flex-col items-center max-w-lg w-full">
        
        <!-- Scoreboard -->
        <div id="scoreboard" class="w-full text-center p-2 mb-4 rounded-lg bg-gray-900 shadow-xl">
            <div class="text-xs font-semibold text-gray-400 mb-1">Scoreboard</div>
            <div class="flex justify-center items-center space-x-4">
                <span class="text-2xl font-extrabold text-green-400" id="player-score">0</span>
                <span class="text-xl font-bold text-gray-400">vs</span>
                <span class="text-2xl font-extrabold text-red-400" id="ai-score">0</span>
            </div>
        </div>

        <!-- Elixir Bar (Player) -->
        <div id="elixir-bar" class="w-full bg-gray-700 rounded-lg p-2 mb-4 flex items-center shadow-lg">
            <svg class="w-6 h-6 text-yellow-300 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm0 4a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1z" clip-rule="evenodd"></path>
            </svg>
            <div class="text-white font-bold mr-4">Elixir:</div>
            <div class="flex-grow h-4 bg-gray-800 rounded-full overflow-hidden border border-yellow-500">
                <div id="elixir-fill" class="h-full bg-yellow-500 transition-all duration-300" style="width: 0%;"></div>
            </div>
            <span id="elixir-value" class="ml-2 font-bold text-yellow-300">0 / 10</span>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="380" height="600"></canvas>
        
        <!-- Modal for Game Over / General Messages -->
        <div id="game-message-modal" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-70 z-50">
             <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center border-t-8 border-yellow-500 max-w-md w-full">
                 <h2 id="modal-title" class="text-3xl font-bold text-white mb-4"></h2>
                 <p class="text-gray-400 mb-6 whitespace-pre-wrap text-left" id="modal-text"></p>
                 <button id="modal-restart-button" class="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-4 rounded transition">
                    Start Next Game
                 </button>
             </div>
        </div>

        <!-- Deck Selection Modal -->
        <div id="deck-selection-modal" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-80 z-50 p-4">
            <div class="bg-gray-900 p-6 rounded-xl shadow-2xl max-w-xl w-full border-t-8 border-indigo-500">
                <h2 class="text-3xl font-extrabold text-white mb-2">Build Your Deck</h2>
                <p class="text-indigo-300 mb-4">Select exactly 4 unique cards to take into battle. You have <span id="deck-count" class="font-bold text-yellow-400">0</span>/4 selected.</p>
                
                <div id="deck-card-pool" class="grid grid-cols-4 sm:grid-cols-5 gap-3 max-h-80 overflow-y-auto pr-2">
                    <!-- Cards will be populated here -->
                </div>

                <div class="mt-6 flex justify-between items-center">
                    <p id="deck-error" class="text-red-400 font-medium hidden">Please select exactly 4 cards.</p>
                    <button id="confirm-deck-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-xl transition disabled:opacity-50 disabled:cursor-not-allowed">
                        Confirm Deck (4/4)
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Card Container - Uses Grid for 4 cards per row -->
        <div id="card-container" class="w-full bg-gray-800 rounded-lg p-3 mt-4 grid grid-cols-4 gap-2 shadow-lg border border-gray-600">
            <!-- Cards will be populated dynamically via JavaScript -->
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- Game Constants ---
        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;
        const ELIXIR_RATE = 0.8; 
        const DEPLOYMENT_LINE_Y = 325; 
        const WAYPOINT_TOLERANCE_SQ = 10 * 10; 
        const PULL_RANGE = 70; 
        
        // --- Tower/Building Constants ---
        const KING_TOWER_HP = 3000;
        const KING_TOWER_DAMAGE = 170; 
        const KING_TOWER_HITSPEED = 1.0; 
        const KING_TOWER_RANGE = 110; 
        const PRINCESS_TOWER_HP = 1500; 
        const PRINCESS_TOWER_DAMAGE = 170;
        const PRINCESS_TOWER_HITSPEED = 1.3; 
        const PRINCESS_TOWER_RANGE = 120; 
        const TOWER_RADIUS_P = 20; 
        const TOWER_RADIUS_K = 30; 
        const PLAYER_TOWER_COLOR = '#10b981'; 
        const ENEMY_TOWER_COLOR = '#dc2626'; 
        
        // Fire Wizard AOE Radius
        const FIRE_WIZARD_AOE_RADIUS = 35; // Constant for AOE radius

        // --- Game State ---
        let elixir = 0; 
        let enemyElixir = 0; 
        const MAX_ELIXIR = 10;
        let units = [];
        let buildings = [];
        let projectiles = [];
        let selectedCard = null; 
        let lastTime = 0;
        let animationFrameId = null;
        let aiIntervalId = null; 
        let playerScore = 0;
        let aiScore = 0;
        let isGameOver = false;
        const cardCooldowns = {};
        
        // --- DECK BUILDER STATE ---
        let playerDeck = []; 
        let hasDeckSelectionUnlocked = true; // Always unlocked for simplicity

        // --- DOM Elements ---
        const elixirValueEl = document.getElementById('elixir-value');
        const elixirFillEl = document.getElementById('elixir-fill');
        const cardContainer = document.getElementById('card-container');
        const playerScoreEl = document.getElementById('player-score');
        const aiScoreEl = document.getElementById('ai-score');
        const messageModal = document.getElementById('game-message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalText = document.getElementById('modal-text');
        const modalRestartButton = document.getElementById('modal-restart-button');
        
        // Deck Selection Elements
        const deckSelectionModal = document.getElementById('deck-selection-modal');
        const deckCardPool = document.getElementById('deck-card-pool');
        const confirmDeckButton = document.getElementById('confirm-deck-button');
        const deckCountEl = document.getElementById('deck-count');
        const deckErrorEl = document.getElementById('deck-error');


        // --- Waypoint Constants ---
        const BRIDGE_LEFT_X = 110;
        const BRIDGE_RIGHT_X = 270;
        const BRIDGE_ENTRANCE_Y = 330; 
        const BRIDGE_EXIT_Y = 270; 


   // --- Unit Definitions (ALL CARDS) ---
const FIRE_WIZARD_AOE_RADIUS = 30; // make sure this constant exists

const ALL_CARD_STATS = [
    // Standard Troops
    { name: 'Footman', cost: 3, maxHp: 700, damage: 150, hitspeed: 1.2, speed: 50, radius: 12, color: '#60a5fa', attackRange: 5, emoji: 'ðŸ›¡ï¸', id: 'footman', targetPreference: 'all', cooldown: 2000, spawnCount: 1, isAOE: false },
    { name: 'Spearman', cost: 2, maxHp: 450, damage: 90, hitspeed: 1.0, speed: 55, radius: 10, color: '#14b8a6', attackRange: 5, emoji: 'ðŸ”±', id: 'spearman', targetPreference: 'all', cooldown: 2000, spawnCount: 1, isAOE: false },
    { name: 'Knight', cost: 3, maxHp: 600, damage: 120, hitspeed: 1.1, speed: 40, radius: 12, color: '#9333ea', attackRange: 5, emoji: 'âš”ï¸', id: 'knight', targetPreference: 'all', cooldown: 2000, spawnCount: 1, isAOE: false },
    { name: 'Berserker', cost: 4, maxHp: 500, damage: 150, hitspeed: 0.8, speed: 50, radius: 12, color: '#f97316', attackRange: 5, emoji: 'ðŸª“', id: 'berserker', targetPreference: 'all', cooldown: 2000, spawnCount: 1, isAOE: false },
    
    // Tier 2
    { name: 'War Golem', cost: 7, maxHp: 2200, damage: 300, hitspeed: 2.0, speed: 20, radius: 20, color: '#78716c', attackRange: 5, emoji: 'ðŸª¨', id: 'golem', targetPreference: 'buildings', cooldown: 2000, spawnCount: 1, isAOE: false },
    
    { 
        name: 'Fire Wizard',
        cost: 3,
        maxHp: 400,
        damage: 250,
        hitspeed: 2.0,
        speed: 45,
        radius: 10,
        color: '#f59e0b',
        attackRange: 100,
        emoji: 'ðŸ”¥',
        id: 'wizard',
        targetPreference: 'all',
        cooldown: 2000,
        spawnCount: 1,
        isAOE: true,
        aoeRadius: FIRE_WIZARD_AOE_RADIUS
    },

    // Skeleton Cards
    { name: 'Skeletons', cost: 1, maxHp: 120, damage: 55, hitspeed: 1.0, speed: 60, radius: 8, color: '#f3f4f6', attackRange: 5, emoji: 'ðŸ’€', id: 'skeleton', targetPreference: 'all', cooldown: 2000, spawnCount: 3, isAOE: false },
    { name: 'Ancient Skeleton', cost: 3, maxHp: 650, damage: 180, hitspeed: 1.1, speed: 40, radius: 15, color: '#4b5563', attackRange: 5, emoji: 'ðŸ›¡ï¸ðŸ’€', id: 'ancient-skeleton', targetPreference: 'all', cooldown: 2000, spawnCount: 1, isAncient: true, isAOE: false },

    // Ancient Fire Wizard
    { 
        name: 'Ancient Fire Wizard',
        cost: 4,
        maxHp: 500,
        damage: 200,
        hitspeed: 1.8,
        speed: 45,
        radius: 10,
        color: '#ef4444',
        attackRange: 125,
        emoji: 'ðŸ”¥ðŸ›¡ï¸',
        id: 'ancient-fire-wizard',
        targetPreference: 'all',
        cooldown: 2000,
        spawnCount: 1,
        isAOE: true,
        aoeRadius: 40,
        isAncient: true,
        hasShield: true,
        initialShieldHP: 150,
        shieldDurationMS: 3000
    },

    // Royal Recruits
    {
        name: 'Royal Recruits',
        cost: 7,
        maxHp: 1350,
        damage: 180,
        hitspeed: 1.2,
        speed: 50,
        radius: 12,
        color: '#c084fc',
        attackRange: 25,
        emoji: 'ðŸ›¡ï¸ðŸª–',
        id: 'royal-recruits',
        targetPreference: 'all',
        cooldown: 2000,
        spawnCount: 8,
        isAOE: false
    },

    // --- NEW 4 ORIGINAL TROOPS ---
    {
        name: 'Shadow Assassin',
        cost: 4,
        maxHp: 350,
        damage: 300,
        hitspeed: 0.9,
        speed: 80,
        radius: 10,
        color: '#1f2937',
        attackRange: 10,
        emoji: 'ðŸ—¡ï¸ðŸŒ‘',
        id: 'shadow-assassin',
        targetPreference: 'all',
        cooldown: 2000,
        spawnCount: 1,
        isAOE: false,
        stealth: true,
        stealthDurationMS: 2000
    },
    {
        name: 'Luminous Sprite',
        cost: 3,
        maxHp: 300,
        damage: 120,
        hitspeed: 0.8,
        speed: 75,
        radius: 10,
        color: '#fcd34d',
        attackRange: 90,
        emoji: 'âœ¨ðŸ§š',
        id: 'luminous-sprite',
        targetPreference: 'all',
        cooldown: 2000,
        spawnCount: 1,
        isAOE: true,
        aoeRadius: 20,
        healAllies: true,
        healAmount: 50
    },
    {
        name: 'Iron Fang Wolf',
        cost: 5,
        maxHp: 900,
        damage: 180,
        hitspeed: 1.1,
        speed: 60,
        radius: 12,
        color: '#dc2626',
        attackRange: 15,
        emoji: 'ðŸºâš”ï¸',
        id: 'iron-fang-wolf',
        targetPreference: 'all',
        cooldown: 2000,
        spawnCount: 1,
        isAOE: false,
        biteBoost: true,
        maxBoost: 2
    },
    {
        name: 'Obsidian Sentinel',
        cost: 6,
        maxHp: 2000,
        damage: 220,
        hitspeed: 1.5,
        speed: 35,
        radius: 20,
        color: '#171717',
        attackRange: 30,
        emoji: 'ðŸ—¿ðŸ”¥',
        id: 'obsidian-sentinel',
        targetPreference: 'all',
        cooldown: 2000,
        spawnCount: 1,
        isAOE: false,
        hasShield: true,
        initialShieldHP: 300,
        shieldDurationMS: 5000
    }
];
  
        
        // Initial player deck is empty until selected
        playerDeck = [];


        // --- Utility Functions for Buildings/Towers ---
        function getEnemyKingTower() {
            return buildings.find(b => b.team === 'enemy' && b.isKing);
        }
        function getPlayerKingTower() {
            return buildings.find(b => b.team === 'player' && b.isKing);
        }
        function getEnemyPrincessTowers() {
            return {
                left: buildings.find(b => b.team === 'enemy' && !b.isKing && b.x === BRIDGE_LEFT_X), 
                right: buildings.find(b => b.team === 'enemy' && !b.isKing && b.x === BRIDGE_RIGHT_X)
            };
        }
        function getPlayerPrincessTowers() {
            return {
                left: buildings.find(b => b.team === 'player' && !b.isKing && b.x === BRIDGE_LEFT_X), 
                right: buildings.find(b => b.team === 'player' && !b.isKing && b.x === BRIDGE_RIGHT_X)
            };
        }


        // --- Unit Class ---
        class Unit {
            constructor(x, y, stats, team, path, targetBuilding) {
                this.x = x;
                this.y = y;
                this.stats = stats;
                this.hp = stats.maxHp;
                this.team = team;
                this.isAttacking = false;
                this.finalTarget = targetBuilding; 
                this.path = path; 
                this.currentWaypointIndex = 0;
                this.attackCooldown = 0; 
                this.hitspeedMS = stats.hitspeed * 1000;
                this.hasCrossedBridge = false; 
                this.targetLock = null; 
                
                // For Ancient Skeleton's special attack
                this.attackCounter = 0; 
                this.isStunned = false; 
                
                // Shield Logic for Ancient Fire Wizard
                this.shieldHP = 0;
                this.shieldTimer = 0;
                if (this.stats.hasShield) {
                    this.shieldHP = this.stats.initialShieldHP;
                    this.shieldTimer = this.stats.shieldDurationMS;
                }
            }
            
            // Ancient Skeleton Special Attack (same as before)
            performAncientShockwave() {
                const AOE_DAMAGE = 90;
                const AOE_RADIUS = 60;
                const AOE_RADIUS_SQ = AOE_RADIUS * AOE_RADIUS;
                const STUN_DURATION = 500; 

                // 1. AOE Damage and Stun
                for (const otherUnit of units) {
                    if (otherUnit.team !== this.team && otherUnit.hp > 0) {
                        const dx = otherUnit.x - this.x;
                        const dy = otherUnit.y - this.y;
                        const distanceSq = dx * dx + dy * dy;

                        if (distanceSq <= AOE_RADIUS_SQ) {
                            otherUnit.takeDamage(AOE_DAMAGE);
                            
                            otherUnit.isStunned = true;
                            setTimeout(() => {
                                otherUnit.isStunned = false;
                            }, STUN_DURATION);
                        }
                    }
                }
                
                // 2. Visual Effect
                projectiles.push({
                    start: { x: this.x, y: this.y },
                    end: { x: this.x, y: this.y }, 
                    color: '#facc15', 
                    ttl: 200, 
                    isAOE: true, 
                    radius: AOE_RADIUS,
                    isImpact: true // Mark as an impact effect
                });
            }
            
            // Applies damage to the target and any units in the AOE range
            performAttack(target) {
                if (!target || target.isDestroyed || target.hp <= 0) {
                    this.targetLock = null;
                    return;
                }
                
                // 1. Primary Target Damage
                target.takeDamage(this.stats.damage);
                
                // 2. AOE Logic 
                if (this.stats.isAOE) {
                    const radius = this.stats.aoeRadius || 30; // Use custom AOE radius if available
                    const radiusSq = radius * radius;
                    const targetTeam = target instanceof Unit ? target.team : (this.team === 'player' ? 'enemy' : 'player');
                    
                    for (const otherUnit of units) {
                        // Must be enemy, must not be the primary target (already hit), and must be within the AOE radius of the target's position
                        if (otherUnit.team === targetTeam && otherUnit !== target && otherUnit.hp > 0) {
                            const dx = otherUnit.x - target.x;
                            const dy = otherUnit.y - target.y;
                            const distanceSq = dx * dx + dy * dy;

                            if (distanceSq <= radiusSq) {
                                // AOE Damage is 50%
                                otherUnit.takeDamage(this.stats.damage * 0.5); 
                            }
                        }
                    }
                    
                    // Add an AOE impact visual effect at the target location
                    projectiles.push({
                        start: { x: target.x, y: target.y },
                        end: { x: target.x, y: target.y }, 
                        color: this.stats.color, 
                        ttl: 200, 
                        isAOE: true, 
                        radius: radius,
                        isImpact: true 
                    });
                }
                
                // 3. Ancient Skeleton Special Attack Check
                if (this.stats.id === 'ancient-skeleton') {
                    this.attackCounter++;
                    if (this.attackCounter % 3 === 0) {
                        this.performAncientShockwave();
                    }
                }

            }

            draw() {
                // 1. Draw Unit Body (Circle)
                ctx.fillStyle = this.stats.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.stats.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 2. Draw Shield Visual (if active)
                if (this.shieldHP > 0) {
                    ctx.strokeStyle = '#60a5fa'; // Blue outline for shield
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.radius + 4, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // 3. Draw Emoji
                ctx.font = '16px sans-serif'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.stats.emoji, this.x, this.y - 2); 
                
                // 4. Draw Health and Shield Bar
                const totalBarWidth = 30;
                const barY = this.y - this.stats.radius - 10;

                // Health bar background
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x - 15, barY, totalBarWidth, 5);
                
                // Draw HP (Base layer)
                const hpPercent = this.hp / this.stats.maxHp;
                const hpWidth = totalBarWidth * hpPercent;
                ctx.fillStyle = hpPercent > 0.3 ? 'lime' : 'red';
                ctx.fillRect(this.x - 15, barY, hpWidth, 5);

                // Draw SHIELD on top of HP (if present)
                if (this.shieldHP > 0 && this.stats.initialShieldHP) {
                    // Total effective health (HP + Shield) for bar calculation
                    const totalEffectiveHP = this.stats.maxHp + this.stats.initialShieldHP;
                    
                    // Calculate relative width of HP segment
                    const hpSegmentWidth = totalBarWidth * (this.hp / totalEffectiveHP);
                    
                    // Calculate relative width of Shield segment
                    const shieldSegmentWidth = totalBarWidth * (this.shieldHP / totalEffectiveHP);

                    // Starting position for the shield bar segment (after the current HP)
                    const shieldStartX = this.x - 15 + hpSegmentWidth;

                    ctx.fillStyle = '#60a5fa'; // Light blue for shield
                    ctx.fillRect(shieldStartX, barY, shieldSegmentWidth, 5);
                }
            }
            
            takeDamage(damage) {
                if (this.hp <= 0) return;

                let remainingDamage = damage;
                
                // 1. Check for shield
                if (this.shieldHP > 0) {
                    if (remainingDamage >= this.shieldHP) {
                        remainingDamage -= this.shieldHP;
                        this.shieldHP = 0;
                    } else {
                        this.shieldHP -= remainingDamage;
                        this.shieldHP = Math.max(0, this.shieldHP); // Ensure shield doesn't go negative
                        remainingDamage = 0;
                    }
                }

                // 2. Apply remaining damage to HP
                this.hp -= remainingDamage;
                if (this.hp <= 0) {
                    this.hp = 0;
                }
            }

            getCurrentTarget() {
                if (this.currentWaypointIndex < this.path.length) {
                    return this.path[this.currentWaypointIndex];
                }
                return this.finalTarget;
            }
            
            findClosestEnemyUnit() {
                let closestUnit = null;
                let minDistanceSq = Infinity;
                
                const maxPullSq = PULL_RANGE * PULL_RANGE; 

                for (const otherUnit of units) {
                    if (otherUnit.team !== this.team && otherUnit.hp > 0) {
                        const dx = otherUnit.x - this.x;
                        const dy = otherUnit.y - this.y;
                        const distanceSq = dx * dx + dy * dy;
                        
                        // Check against the pull range
                        if (distanceSq > maxPullSq) {
                             continue; 
                        }

                        if (distanceSq < minDistanceSq) { 
                            minDistanceSq = distanceSq;
                            closestUnit = otherUnit;
                        }
                    }
                }
                return closestUnit;
            }


            update(deltaTime) {
                const dt = deltaTime / 1000;
                
                if (this.hp <= 0) return;

                // --- Step 0a: Update Bridge Status ---
                if (this.team === 'player' && this.y <= BRIDGE_EXIT_Y) {
                    this.hasCrossedBridge = true;
                } 
                else if (this.team === 'enemy' && this.y >= BRIDGE_ENTRANCE_Y) {
                    this.hasCrossedBridge = true;
                }
                
                // --- Step 0b: Update Shield Timer ---
                if (this.shieldHP > 0 && this.stats.hasShield) {
                    this.shieldTimer -= deltaTime;
                    if (this.shieldTimer <= 0) {
                        this.shieldHP = 0;
                    }
                }
                
                // --- Step 0c: Handle King Tower Retargeting & Lock Check ---
                if (this.finalTarget.isDestroyed) {
                    const kingTower = this.team === 'player' ? getEnemyKingTower() : getPlayerKingTower();
                    
                    if (kingTower && !kingTower.isDestroyed) {
                        this.finalTarget = kingTower;
                        this.path = []; 
                        this.currentWaypointIndex = 0;
                        this.isAttacking = false;
                    } else {
                        return; 
                    }
                }

                if (this.targetLock && (this.targetLock.isDestroyed || this.targetLock.hp <= 0)) {
                    this.targetLock = null; 
                }
                
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= deltaTime;
                }

                // --- Step 1: DETERMINE TARGET ---
                let movementTarget = this.getCurrentTarget(); 
                let attackTarget = null;
                
                if (this.targetLock) {
                    attackTarget = this.targetLock;
                    movementTarget = this.targetLock; 
                } else {
                    let closestUnit = null;

                    if (this.stats.targetPreference !== 'buildings') {
                        closestUnit = this.findClosestEnemyUnit();
                    }
                    
                    if (closestUnit) {
                        attackTarget = closestUnit;
                        movementTarget = closestUnit; 

                        // Pathing Enforcement for River Crossing 
                        if (!this.hasCrossedBridge) {
                            let targetIsAcrossRiver = false;
                            
                            if (this.team === 'player' && closestUnit.y <= BRIDGE_EXIT_Y) {
                                targetIsAcrossRiver = true; 
                            } else if (this.team === 'enemy' && closestUnit.y >= BRIDGE_ENTRANCE_Y) {
                                targetIsAcrossRiver = true;
                            }
                            
                            // If enemy is across the river, ignore it and stick to path.
                            if (targetIsAcrossRiver) {
                                movementTarget = this.getCurrentTarget(); 
                                attackTarget = null; 
                            }
                        }
                    } else {
                        // If no units, target the final objective
                        attackTarget = this.finalTarget;
                        movementTarget = this.getCurrentTarget(); 
                    }
                }
                
                // --- Step 2: CALCULATE Distance & Effective Range ---
                
                const target = movementTarget;
                if (!target) return;

                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const minDistanceSq = dx * dx + dy * dy;
                const distance = Math.sqrt(minDistanceSq);
                
                let effectiveAttackRange = 0;
                let targetIsAttackable = false;

                if (target instanceof Unit) {
                    effectiveAttackRange = this.stats.attackRange + target.stats.radius + this.stats.radius;
                    targetIsAttackable = (attackTarget === target); 
                } else if (target instanceof Building) {
                    effectiveAttackRange = this.stats.attackRange + target.radius + this.stats.radius;
                    targetIsAttackable = (attackTarget === target);
                } else {
                    effectiveAttackRange = 0;
                }

                
                // --- Step 3: EXECUTE ACTION ---
                
                if (targetIsAttackable && distance <= effectiveAttackRange) {
                    this.targetLock = attackTarget; 
                    
                    this.isAttacking = true;
                    if (this.attackCooldown <= 0) {
                        
                        // Perform the primary attack (handles AOE and Ancient Skeleton special inside)
                        this.performAttack(attackTarget);
                        
                        this.attackCooldown = this.hitspeedMS;
                        
                        // Projectiles only for ranged units
                        if (this.stats.attackRange > 5) {
                            this.drawProjectile(attackTarget);
                        }
                    }
                    return; 
                }
                
                // Move Phase
                if (this.isStunned) return; // Prevent movement if stunned (simplified knockback
                
                if (this.currentWaypointIndex < this.path.length && target === this.path[this.currentWaypointIndex]) {
                    if (minDistanceSq < WAYPOINT_TOLERANCE_SQ) {
                        this.currentWaypointIndex++;
                        this.isAttacking = false;
                        return; 
                    }
                }
                
                this.isAttacking = false;
                const directionX = (target.x - this.x) / distance;
                const directionY = (target.y - this.y) / distance;

                this.x += directionX * this.stats.speed * dt;
                this.y += directionY * this.stats.speed * dt;
            }
            
            drawProjectile(target) {
                // Add a projectile to the global list
                projectiles.push({
                    start: { x: this.x, y: this.y },
                    end: { x: target.x, y: target.y },
                    color: this.stats.color,
                    ttl: 300, 
                    isRanged: true,
                    // If the unit is the Fire Wizard, mark the projectile for AOE impact handling
                    isAOEProjectile: this.stats.isAOE 
                });
            }
        }
        
        // --- Building Class (The Towers) ---
        class Building {
            constructor(x, y, radius, maxHp, color, isKing, team, attackStats = {}, emoji = '') {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.maxHp = maxHp;
                this.hp = maxHp;
                this.color = color;
                this.isKing = isKing;
                this.team = team;
                this.attackStats = attackStats;
                this.emoji = emoji;
                this.isDestroyed = false;
                this.attackCooldown = 0;
                this.isActivated = !isKing; // King Tower starts inactive
            }

            takeDamage(damage) {
                if (this.isDestroyed) return;
                
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.isDestroyed = true;
                    this.handleDestruction();
                }
            }
            
            handleDestruction() {
                if (this.isKing) {
                    stopGameLoop();
                    
                    if (this.team === 'player') {
                        aiScore++;
                        updateScoreboard();
                        displayMessage("DEFEAT!", "Your King Tower has fallen! AI wins the round.", true);
                    } else {
                        playerScore++;
                        updateScoreboard();
                        displayMessage("VICTORY!", "The Enemy King Tower has been destroyed! You win the round.", true);
                    }
                    isGameOver = true;
                    
                } else {
                    // Princess Tower is destroyed, activate the King Tower
                    const kingTower = this.team === 'player' ? getPlayerKingTower() : getEnemyKingTower();
                    if (kingTower && !kingTower.isDestroyed) {
                        kingTower.isActivated = true;
                    }
                }
            }

            update(deltaTime) {
                if (this.isDestroyed || !this.attackStats.range || !this.isActivated) return;

                this.attackCooldown -= deltaTime;

                // 1. Find Nearest Enemy Unit
                let nearestEnemy = null;
                let minDistanceSq = Infinity;
                const rangeSq = this.attackStats.range * this.attackStats.range;
                
                const targetTeam = this.team === 'player' ? 'enemy' : 'player';

                for (const unit of units) {
                    if (unit.team === targetTeam) { 
                        const dx = unit.x - this.x;
                        const dy = unit.y - this.y;
                        const distanceSq = dx * dx + dy * dy;
                        
                        if (distanceSq < minDistanceSq && distanceSq <= rangeSq) {
                            minDistanceSq = distanceSq;
                            nearestEnemy = unit;
                        }
                    }
                }
                
                // 2. Attack Logic
                if (nearestEnemy) {
                    if (this.attackCooldown <= 0) {
                        nearestEnemy.takeDamage(this.attackStats.damage); 
                        this.drawProjectile(nearestEnemy);
                        this.attackCooldown = this.attackStats.hitspeed * 1000; 
                    }
                }
            }

            draw() {
                if (this.isDestroyed) {
                    ctx.fillStyle = '#4b5563'; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                    ctx.font = '20px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#1f2937';
                    ctx.fillText('ðŸ’¥', this.x, this.y);
                    return;
                }

                // Base
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                
                // Draw Activation Indicator (for King Tower)
                if (this.isKing && !this.isActivated) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                    ctx.fillStyle = '#9ca3af'; 
                } else {
                    ctx.fillStyle = '#fef3c7'; 
                }

                // Draw Emoji
                ctx.font = this.isKing ? '30px sans-serif' : '20px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y + (this.isKing ? 0 : 2));

                // Health bar background
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, this.radius * 2, 5);
                
                // Health bar fill
                const hpPercent = this.hp / this.maxHp;
                const hpWidth = this.radius * 2 * hpPercent;
                ctx.fillStyle = hpPercent > 0.3 ? 'lime' : 'red';
                ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, hpWidth, 5);
            }
            
            drawProjectile(target) {
                // Add a projectile to the global list
                projectiles.push({
                    start: { x: this.x, y: this.y },
                    end: { x: target.x, y: target.y },
                    color: this.color,
                    ttl: 300,
                    isRanged: false,
                    isAOEProjectile: false 
                });
            }
        }
        
        // --- Draw Map Elements (River and Bridges - CR Style) ---
        function drawMap() {
            // River
            const riverHeight = 50; 
            const riverY = GAME_HEIGHT / 2 - riverHeight / 2; 
            ctx.fillStyle = '#4f94d4'; 
            ctx.fillRect(0, riverY, GAME_WIDTH, riverHeight);

            // Bridges 
            const bridgeColor = '#a0522d'; 
            const bridgeOutline = '#4b5563'; 
            const bridgeWidth = 60;
            const bridgeHeight = riverHeight + 10; 
            
            const bridgeLeftX = 80; 
            const bridgeRightX = 240; 

            // Draw Outlines
            ctx.fillStyle = bridgeOutline;
            ctx.fillRect(bridgeLeftX - 5, riverY - 5, bridgeWidth + 10, bridgeHeight + 10);
            ctx.fillRect(bridgeRightX - 5, riverY - 5, bridgeWidth + 10, bridgeHeight + 10);

            // Draw Wood
            ctx.fillStyle = bridgeColor;
            ctx.fillRect(bridgeLeftX, riverY, bridgeWidth, bridgeHeight);
            ctx.fillRect(bridgeRightX, riverY, bridgeWidth, bridgeHeight);

            // Draw Shorelines
            ctx.strokeStyle = '#228b22'; 
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, riverY);
            ctx.lineTo(GAME_WIDTH, riverY);
            ctx.moveTo(0, riverY + riverHeight);
            ctx.lineTo(GAME_WIDTH, riverY + riverHeight);
            ctx.stroke();
        }

        // --- Deployment Logic ---
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }
        
        function isPlacementValid(y) {
            return y >= DEPLOYMENT_LINE_Y;
        }
        
        function generatePath(spawnX, team) {
            const path = [];
            const isLeftLane = spawnX < GAME_WIDTH / 2;
            const bridgeX = isLeftLane ? BRIDGE_LEFT_X : BRIDGE_RIGHT_X;
            
            let entranceY, exitY;
            if (team === 'player') {
                entranceY = BRIDGE_ENTRANCE_Y; 
                exitY = BRIDGE_EXIT_Y;
            } else { // team === 'enemy'
                entranceY = BRIDGE_EXIT_Y; 
                exitY = BRIDGE_ENTRANCE_Y;
            }
            
            path.push({ x: bridgeX, y: entranceY });
            path.push({ x: bridgeX, y: exitY });
            
            return path;
        }
        
        function spawnUnit(x, y, stats, team) {
            // 1. Determine final target tower
            const isLeftLane = x < GAME_WIDTH / 2;
            let targetTower;
            
            if (team === 'player') {
                const towers = getEnemyPrincessTowers();
                targetTower = isLeftLane ? towers.left : towers.right;
                if (targetTower.isDestroyed) {
                    targetTower = getEnemyKingTower();
                }
            } else { // team === 'enemy'
                const towers = getPlayerPrincessTowers();
                targetTower = isLeftLane ? towers.left : towers.right;
                if (targetTower.isDestroyed) {
                    targetTower = getPlayerKingTower();
                }
            }
            
            // 2. Generate path
            let path = generatePath(x, team);

            // 3. Create and add unit(s) - Handles multi-spawn like Skeletons
            if (targetTower && !targetTower.isDestroyed) { 
                const count = stats.spawnCount || 1;
                
                for (let i = 0; i < count; i++) {
                    let spawnX = x;
                    let spawnY = y;

                    // Slight offset for multiple units (Skeletons)
                    if (count > 1) {
                        // Offset horizontally and slightly vertically to spread them out
                        const offset = (i - Math.floor(count / 2)) * (stats.radius * 2 + 2);
                        spawnX += offset;
                        spawnY += (i % 2 === 0 ? 0 : stats.radius * 0.5); 
                    }

                    const unit = new Unit(spawnX, spawnY, stats, team, path, targetTower);
                    units.push(unit);
                }
                
                // Set cooldown after deployment
                if (stats.cooldown > 0) {
                     const cooldownKey = team === 'player' ? stats.id : stats.id + '_ai';
                     cardCooldowns[cooldownKey] = stats.cooldown;
                }
            }
        }


        function handleCardClick(stats) {
            const cardEl = document.getElementById(stats.id + '-card');
            
            if (cardCooldowns[stats.id] || elixir < stats.cost) return;

            // Clear active state from all cards
            playerDeck.forEach(s => {
                document.getElementById(s.id + '-card')?.classList.remove('card-active');
            });

            if (selectedCard === stats) {
                selectedCard = null;
            } else {
                selectedCard = stats;
                cardEl.classList.add('card-active');
            }
        }

        function handleCanvasClick(event) {
            if (!selectedCard || isGameOver) return;

            const pos = getMousePos(event);
            
            if (isPlacementValid(pos.y)) {
                const deployedCardStats = selectedCard;
                
                if (cardCooldowns[deployedCardStats.id] || elixir < deployedCardStats.cost) return;
                
                elixir -= deployedCardStats.cost;
                
                spawnUnit(pos.x, pos.y, deployedCardStats, 'player');
                
                document.getElementById(deployedCardStats.id + '-card')?.classList.remove('card-active');
                selectedCard = null;

            } else {
                console.log("Invalid placement area! Must be on your side of the river (Y >= 325).");
            }
        }
        
        let mouseX = 0;
        let mouseY = 0;

        function handleMouseMove(event) {
            const pos = getMousePos(event);
            mouseX = pos.x;
            mouseY = pos.y;
        }

        function drawDeploymentVisual() {
            if (selectedCard) {
                // Draw a translucent circle at the mouse position
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, selectedCard.radius + 15, 0, Math.PI * 2);
                
                if (isPlacementValid(mouseY)) {
                    ctx.fillStyle = 'rgba(16, 185, 129, 0.5)'; 
                } else {
                    ctx.fillStyle = 'rgba(220, 38, 38, 0.5)'; 
                }
                ctx.fill();
            }
        }

        // --- Scoreboard and Message Handlers ---
        function updateScoreboard() {
            playerScoreEl.textContent = playerScore;
            aiScoreEl.textContent = aiScore;
        }
        
        function displayMessage(title, text, isGameEnd) {
             modalTitle.textContent = title;
             modalText.textContent = text;
             
             // No conditional text/button based on milestone anymore, always "Start Next Game"
             modalRestartButton.textContent = "Start Next Game"; 
             
             messageModal.classList.remove('hidden');
        }

        // --- AI LOGIC IMPLEMENTATION ---
        let aiAvailableCards = []; // AI's current deck (4 cards)

        function selectAICardPool() {
             // AI always uses a random 4 cards from the full pool
             aiAvailableCards = shuffle(ALL_CARD_STATS).slice(0, 4);
        }

        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
            return array;
        }
        
        function aiTurn() {
            if (isGameOver) return;
            
            // Filter cards that are NOT on cooldown for the AI
            const available = aiAvailableCards.filter(stats => !cardCooldowns[stats.id + '_ai']);

            const affordableCards = available
                .filter(stats => stats.cost <= enemyElixir)
                .sort((a, b) => b.cost - a.cost); 

            if (affordableCards.length === 0) {
                return; 
            }
            
            // Target Lane determination (prioritize the most damaged/missing Princess Tower)
            const playerTowers = getPlayerPrincessTowers();
            const kingTower = getPlayerKingTower();
            let targetX;
            
            // Calculate health percentage for active towers
            const leftHP = playerTowers.left.isDestroyed ? -1 : playerTowers.left.hp;
            const rightHP = playerTowers.right.isDestroyed ? -1 : playerTowers.right.hp;
            
            if (leftHP === -1 && rightHP !== -1) {
                targetX = BRIDGE_RIGHT_X; // Left is dead, go right
            } else if (rightHP === -1 && leftHP !== -1) {
                targetX = BRIDGE_LEFT_X; // Right is dead, go left
            } else if (leftHP !== -1 && rightHP !== -1) {
                targetX = leftHP <= rightHP ? BRIDGE_LEFT_X : BRIDGE_RIGHT_X; // Go for lower HP
            } else {
                targetX = GAME_WIDTH / 2; // Both down, go for King Tower (center deploy)
            }


            // Select Card and Deploy
            const selectedStats = affordableCards[0]; 

            enemyElixir -= selectedStats.cost;

            const deploymentY = 100; // Deploy in the AI's zone

            // Deployment will set the AI cooldown via spawnUnit function
            spawnUnit(targetX, deploymentY, selectedStats, 'enemy');
        }
        
        // --- Deck Selection Logic ---
        function openDeckSelectionModal() {
            deckSelectionModal.classList.remove('hidden');
            renderDeckCardPool();
            updateDeckSelectionUI();
        }
        
        function renderDeckCardPool() {
            deckCardPool.innerHTML = '';
            ALL_CARD_STATS.forEach(stats => {
                // Check if the card is in the current playerDeck
                const isSelected = playerDeck.some(card => card.id === stats.id);
                
                // Check if this is an Ancient card for the glow effect
                const isAncient = stats.isAncient;
                
                const cardEl = document.createElement('div');
                cardEl.id = 'deck-' + stats.id;
                
                // Show cooldown on card pool description
                const cooldownSeconds = stats.cooldown / 1000;
                
                const cardColor = 'bg-gray-700'; // Default card color
                
                // Apply evo-glow class only to Ancient cards
                const glowClass = isAncient ? 'evo-glow' : '';

                cardEl.className = `deck-card ${cardColor} ${glowClass} text-white font-bold p-2 flex flex-col items-center rounded-lg shadow-md hover:shadow-xl transition ${isSelected ? 'selected' : ''}`;
                
                const unitCountText = stats.spawnCount > 1 ? ` (x${stats.spawnCount})` : '';
                
                cardEl.innerHTML = `
                    <div class="text-xl">${stats.emoji}</div>
                    <div class="text-xs text-center leading-tight mt-1">${stats.name}${unitCountText}</div>
                    <div class="text-xs bg-gray-900 px-1 py-0.5 rounded-full text-yellow-300 mt-1">${stats.cost} Elixir / ${cooldownSeconds}s CD</div>
                `;
                
                cardEl.addEventListener('click', () => toggleDeckCard(stats));
                deckCardPool.appendChild(cardEl);
            });
        }
        
        function toggleDeckCard(stats) {
            const index = playerDeck.findIndex(card => card.id === stats.id);
            const cardEl = document.getElementById('deck-' + stats.id);
            
            if (index > -1) {
                // Deselect
                playerDeck.splice(index, 1);
                cardEl.classList.remove('selected');
            } else if (playerDeck.length < 4) {
                // Select
                playerDeck.push(stats);
                cardEl.classList.add('selected');
            }
            updateDeckSelectionUI();
        }
        
        function updateDeckSelectionUI() {
            deckCountEl.textContent = playerDeck.length;
            confirmDeckButton.textContent = `Confirm Deck (${playerDeck.length}/4)`;
            
            if (playerDeck.length === 4) {
                confirmDeckButton.disabled = false;
                deckErrorEl.classList.add('hidden');
            } else {
                confirmDeckButton.disabled = true;
                deckErrorEl.classList.remove('hidden');
            }
            
            // Disable selection of other cards if 4 are already selected
            ALL_CARD_STATS.forEach(stats => {
                const el = document.getElementById('deck-' + stats.id);
                if (el && playerDeck.length === 4 && !el.classList.contains('selected')) {
                    el.classList.add('opacity-50', 'pointer-events-none');
                } else if (el) {
                    el.classList.remove('opacity-50', 'pointer-events-none');
                }
            });
        }

        function confirmDeck() {
            if (playerDeck.length === 4) {
                deckSelectionModal.classList.add('hidden');
                startNewGame();
            }
        }
        // --- End Deck Selection Logic ---
        
        // --- Game Setup ---
        function initializeBuildings() {
            buildings = [];
            
            const KING_ATTACK_STATS = { damage: KING_TOWER_DAMAGE, hitspeed: KING_TOWER_HITSPEED, range: KING_TOWER_RANGE };
            const PRINCESS_ATTACK_STATS = { damage: PRINCESS_TOWER_DAMAGE, hitspeed: PRINCESS_TOWER_HITSPEED, range: PRINCESS_TOWER_RANGE };

            // Player Towers (Team 'player' - Green)
            buildings.push(new Building(190, 540, TOWER_RADIUS_K, KING_TOWER_HP, PLAYER_TOWER_COLOR, true, 'player', KING_ATTACK_STATS, 'ðŸ‘‘')); 
            buildings.push(new Building(110, 420, TOWER_RADIUS_P, PRINCESS_TOWER_HP, PLAYER_TOWER_COLOR, false, 'player', PRINCESS_ATTACK_STATS, 'ðŸ‘¸')); 
            buildings.push(new Building(270, 420, TOWER_RADIUS_P, PRINCESS_TOWER_HP, PLAYER_TOWER_COLOR, false, 'player', PRINCESS_ATTACK_STATS, 'ðŸ‘¸')); 
            
            // Enemy Towers (Team 'enemy' - Red)
            buildings.push(new Building(190, 60, TOWER_RADIUS_K, KING_TOWER_HP, ENEMY_TOWER_COLOR, true, 'enemy', KING_ATTACK_STATS, 'ðŸ‘‘')); 
            buildings.push(new Building(110, 180, TOWER_RADIUS_P, PRINCESS_TOWER_HP, ENEMY_TOWER_COLOR, false, 'enemy', PRINCESS_ATTACK_STATS, 'ðŸ‘¸')); 
            buildings.push(new Building(270, 180, TOWER_RADIUS_P, PRINCESS_TOWER_HP, ENEMY_TOWER_COLOR, false, 'enemy', PRINCESS_ATTACK_STATS, 'ðŸ‘¸')); 
        }
        
        function createCardButtons() {
            // Render the player's active 4-card deck
            cardContainer.innerHTML = ''; 
            playerDeck.forEach(stats => {
                const button = document.createElement('button');
                button.id = stats.id + '-card';
                
                const cardColor = 'bg-gray-700'; 
                button.className = `card-button ${cardColor} text-white font-bold p-2 h-24 flex flex-col justify-between items-center rounded-xl shadow-lg border-b-4 border-gray-900 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed`;
                
                const unitCountText = stats.spawnCount > 1 ? ` (x${stats.spawnCount})` : '';
                const cooldownSeconds = stats.cooldown / 1000;

                button.innerHTML = `
                    <div class="text-xl">${stats.emoji}</div>
                    <div class="text-xs text-center leading-tight">${stats.name}${unitCountText}</div>
                    <div class="text-xs bg-gray-900 px-2 py-0.5 rounded-full text-yellow-300">${stats.cost} Elixir / ${cooldownSeconds}s CD</div>
                    <div id="${stats.id}-cooldown" class="card-cooldown-overlay hidden"></div>
                `;
                button.addEventListener('click', () => handleCardClick(stats));
                cardContainer.appendChild(button);
            });
        }
        
        function setupEventListeners() {
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleMouseMove);
            
            // Simplified restart logic: always start a new game immediately
            modalRestartButton.addEventListener('click', () => {
                 messageModal.classList.add('hidden');
                 openDeckSelectionModal(); // Open deck selector after a game ends
            });
            confirmDeckButton.addEventListener('click', confirmDeck);
        }
        
        function startNewGame() {
            // Guard clause to ensure the deck is selected
            if (playerDeck.length !== 4) {
                 openDeckSelectionModal();
                 return;
            }
            
            units = [];
            projectiles = [];
            
            elixir = 0; 
            enemyElixir = 0;
            
            isGameOver = false;
            selectedCard = null;
            Object.keys(cardCooldowns).forEach(key => delete cardCooldowns[key]);
            
            initializeBuildings();
            
            // Select AI's 4-card deck
            selectAICardPool();
            
            // Render player's 4-card deck
            createCardButtons();
            
            lastTime = performance.now();
            if (aiIntervalId) {
                clearInterval(aiIntervalId);
            }
            aiIntervalId = setInterval(aiTurn, 2000); 
            gameLoop(lastTime);
        }

        // --- Elixir and Cooldown Logic ---
        function updateElixir(deltaTime) {
            const dt = deltaTime / 1000;
            
            if (elixir < MAX_ELIXIR) {
                elixir += ELIXIR_RATE * dt;
                if (elixir > MAX_ELIXIR) {
                    elixir = MAX_ELIXIR;
                }
            }
            
            if (enemyElixir < MAX_ELIXIR) {
                enemyElixir += ELIXIR_RATE * dt;
                if (enemyElixir > MAX_ELIXIR) {
                    enemyElixir = MAX_ELIXIR;
                }
            }
            
            // Update Player Cooldowns
            playerDeck.forEach(stats => {
                const cooldownKey = stats.id;
                const cardEl = document.getElementById(cooldownKey + '-card');
                const cooldownEl = document.getElementById(cooldownKey + '-cooldown');
                let cooldownRemaining = cardCooldowns[cooldownKey] || 0;
                
                if (!cardEl) return; 

                if (cooldownRemaining > 0) {
                    cooldownRemaining -= deltaTime;
                    cardCooldowns[cooldownKey] = cooldownRemaining;
                    
                    const timeRemaining = Math.ceil(cooldownRemaining / 1000);
                    cooldownEl.textContent = timeRemaining;
                    cooldownEl.classList.remove('hidden');
                    cardEl.disabled = true;

                    if (selectedCard && selectedCard.id === cooldownKey) {
                         selectedCard = null;
                         cardEl.classList.remove('card-active');
                    }
                } else {
                    delete cardCooldowns[cooldownKey];
                    cooldownEl.classList.add('hidden');
                    cardEl.disabled = elixir < stats.cost;
                }
            });

            // Update AI Cooldowns (just for the AI logic, no UI rendered)
            aiAvailableCards.forEach(stats => {
                const key = stats.id + '_ai'; // Unique key for AI card cooldowns
                let cooldownRemaining = cardCooldowns[key] || 0;
                if (cooldownRemaining > 0) {
                    cooldownRemaining -= deltaTime;
                    cardCooldowns[key] = cooldownRemaining;
                } else {
                    delete cardCooldowns[key];
                }
            });

            // Update Elixir UI
            const elixirPct = (elixir / MAX_ELIXIR) * 100;
            elixirFillEl.style.width = `${elixirPct}%`;
            elixirValueEl.textContent = `${Math.floor(elixir)} / ${MAX_ELIXIR}`;
        }

        // --- Projectile Drawing ---
        function drawProjectiles(deltaTime) {
            projectiles.forEach(p => {
                p.ttl -= deltaTime;
                if (p.ttl > 0) {
                    // Check if it's an impact effect (Ancient Skeleton Shockwave or Fire Wizard AOE impact)
                    if (p.isImpact) { 
                        const opacity = p.ttl / 200; 
                        ctx.strokeStyle = `rgba(250, 204, 21, ${opacity})`; // Yellow for shockwave
                        if (p.color === '#f59e0b') { // Orange for Fire Wizard
                            ctx.strokeStyle = `rgba(245, 158, 11, ${opacity})`; 
                        }
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.arc(p.start.x, p.start.y, p.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                    } else if (p.isRanged) {
                        // Draw standard projectile line
                        ctx.strokeStyle = p.color;
                        ctx.lineWidth = 3; 
                        ctx.beginPath();
                        ctx.moveTo(p.start.x, p.start.y);
                        const progress = (300 - p.ttl) / 300; 
                        const currentX = p.start.x + (p.end.x - p.start.x) * progress;
                        const currentY = p.start.y + (p.end.y - p.start.y) * progress;
                        ctx.lineTo(currentX, currentY);
                        ctx.stroke();
                        
                    }
                }
            });
            projectiles = projectiles.filter(p => p.ttl > 0);
        }

        // --- Game Loop ---
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (isGameOver) {
                stopGameLoop(); 
                return;
            }

            // 1. Clear Canvas
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // 2. Draw Map Elements (River and Bridges)
            drawMap();

            // 3. Update Game Logic
            updateElixir(deltaTime);
            
            buildings.forEach(building => building.update(deltaTime)); 
            
            units.forEach(unit => unit.update(deltaTime));
            units = units.filter(unit => unit.hp > 0); 

            // 4. Draw Elements
            drawProjectiles(deltaTime);
            buildings.forEach(building => building.draw());
            units.forEach(unit => unit.draw());
            
            // 5. Draw deployment indicator last
            drawDeploymentVisual();

            // 6. Request Next Frame
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function stopGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (aiIntervalId) {
                clearInterval(aiIntervalId);
                aiIntervalId = null;
            }
        }

        // --- Initial Call ---
        window.onload = function() {
            updateScoreboard(); 
            setupEventListeners();
            
            // Start by immediately prompting deck selection
ue        };

    </script>
</body>
</html>
